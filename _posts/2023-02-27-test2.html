<<<<<<< HEAD
---
layout: post
mathjax: true
title:  "How did I set up my blog using Jekyll, Hyde and GitHub"
date:   2019-09-25
---

What would be a better way to start this blog than writing a post about how I set it up? Because after three days of sifting through all the documents, blogs, StackOverflow answers and GitHub issues, I finally realized that the process is not as straightforward as I thought it would be. Anyway, I got it to work (for now).

My aim is simple, to set up a blog for myself where I can post stuff about my life. The blog needs to be free, elegant, intuitive and supports math. My current set up, Jekyll + Hyde + Github + MathJax, matches with that. Since there are many resources online about setting up a blog using Jekyll and serve it with GitHub, I am going to skip all the standard procedures by referring to the official documents. Instead, this post specifically documents:
- the sequence of setting up different parts,
- adding support for Tags, Categories and their corresponding pages,
- adding MathJax to support $\LaTeX$-like math.

I am using a macbook, so the steps will be described assuming the system is macOS. When in doubt, just google the relevant steps for other OSs.

## 1. Set up Jekyll
Jekyll is the package that is generating all your website pages. First thing you want to do is to make sure that [Jekyll](https://jekyllrb.com) is installed and ready to run.

## 5. Add MathJax

#### Tips
#### Math Rendering Showcase
- Inline math using `\$...\$`: $\mathbf{x}+\mathbf{y}$.
- Displayed math using `\$\$...\$\$` on a new paragraph:

<div>
$$
\hat{\mathbf{\Sigma}}_k (\alpha) = \alpha \hat{\mathbf{\Sigma}}_k + (1-\alpha) \hat{\mathbf{\Sigma}} \,.
$$
</div>

In (\ref{eq:sample}), we find the value of an interesting integral:

<div>
$$
\begin{align}
  \int_0^\infty \frac{x^3}{e^x-1}\,dx = \frac{\pi^4}{15} \, .
  \label{eq:sample}
\end{align}
$$
</div>

- Multiline equations

<div>
$$
\begin{align*}
  \nabla \times \vec{\mathbf{B}} -\, \frac1c\, \frac{\partial\vec{\mathbf{E}}}{\partial t} & = \frac{4\pi}{c}\vec{\mathbf{j}} \,,\newline
  \nabla \cdot \vec{\mathbf{E}} & = 4 \pi \rho \,.
\end{align*}
$$
</div>

That's it for now. Happy blogging.

Additional resources:
- Set up [categories & tags](https://blog.webjeda.com/jekyll-categories/)
- Set up [Disqus comments & Google Analytics](http://joshualande.com/jekyll-github-pages-poole)
- Add in social media [icons](https://jreel.github.io/social-media-icons-on-jekyll/)
- kramdown [basics](https://kramdown.gettalong.org/quickref.html)
- MathJax [basics](https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference)
=======
<div class="CJK*">
<p><span>UTF8</span><span>gbsn</span></p>
<h1 id="three-line-summary"> Three line summary</h1>
<ul>
<li><p>The spectrum can be thought of heuristically as the frequencies
that represent an element of a Banach algebra.</p></li>
<li><p>In a unital Banach algebra every element has non-empty
spectrum.</p></li>
<li><p>A commutative Banach algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
can be thought of as a subgroup of continuous functions.</p></li>
</ul>
<h1 id="why-should-i-care">Why should I care?</h1>
<p>We introduce the basis of spectral theory which is useful to ...</p>
<h1 id="preliminary-definitions">Preliminary definitions</h1>
<p>Here I include all the needed definitions. Many of them will be
familiar if the reader has an algebra background and can be skimmed
over.</p>
<div class="definition">
<p><strong>Definition 1</strong>. <em>An <em>algebra</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is a vector space together with a multiplication which is bilinear and
associative. That is,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>c</mi><mo>=</mo><mi>a</mi><mi>c</mi><mo>+</mo><mi>b</mi><mi>c</mi><mo>;</mo><mspace width="1.0em"></mspace><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mi>b</mi><mo>+</mo><mi>a</mi><mi>c</mi><mo>;</mo><mspace width="1.0em"></mspace><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>c</mi><mo>∀</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>∈</mo><mi>A</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;(a+b)c=ac+bc;\quad a(b+c)=ab+ac; \quad a(bc)=(ab)c \forall a,b,c \in A.
&#9;&#9;
\end{aligned}</annotation></semantics></math> Note that in general we do
not require that the product is commutative. Though this will be a
common requirement later on. We will take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
for the remainder to be a vectro space over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℂ</mi><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></em></p>
</div>
<div class="definition">
<p><strong>Definition 2</strong>. <em>Given a norm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">∥</mo><mo>⋅</mo><mo stretchy="false" form="postfix">∥</mo></mrow><annotation encoding="application/x-tex">\lVert \cdot  \rVert</annotation></semantics></math>
on algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
we say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>,</mo><mo stretchy="false" form="prefix">∥</mo><mo stretchy="false" form="postfix">∥</mo><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, \lVert  \rVert)</annotation></semantics></math>
is a <em>normed algebra</em> if the norm is <em>submultiplicative</em>.
That is,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mi>b</mi><mo stretchy="false" form="postfix">∥</mo><mo>≤</mo><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo stretchy="false" form="postfix">∥</mo><mo stretchy="false" form="prefix">∥</mo><mi>b</mi><mo stretchy="false" form="postfix">∥</mo><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\lVert ab \rVert\leq \lVert a \rVert\lVert b \rVert.
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
</div>
<div class="definition">
<p><strong>Definition 3</strong>. <em>We say that a normed algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>,</mo><mo stretchy="false" form="prefix">∥</mo><mo>⋅</mo><mo stretchy="false" form="postfix">∥</mo><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A,\lVert \cdot  \rVert)</annotation></semantics></math>
is a <em>Banach algebra</em> if it is complete. We say that it is
<em>unital</em> if there exists an identity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
for the multiplication
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>a</mi><mn>1</mn><mo>=</mo><mn>1</mn><mi>a</mi><mo>,</mo><mspace width="1.0em"></mspace><mo>∀</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;a 1=1 a, \quad\forall a\in A.
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
<p><em>and we say that it is <em>commutative</em> if
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>a</mi><mi>b</mi><mo>=</mo><mi>b</mi><mi>a</mi><mo>,</mo><mspace width="1.0em"></mspace><mo>∀</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mi>A</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;ab= ba , \quad\forall a,b \in A.
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
</div>
<div class="definition">
<p><strong>Definition 4</strong>. <em>Given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in  A</annotation></semantics></math>
we say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">\lambda  \in \mathbb{C}</annotation></semantics></math>
is in the <em>spectrum</em> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mn>1</mn><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\lambda 1-a</annotation></semantics></math>
is <strong>not</strong> invertible. We write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊂</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">\sigma (a) \subset \mathbb{C}</annotation></semantics></math>
for the set of such
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</em></p>
</div>
<div class="definition">
<p><strong>Definition 5</strong>. <em>Given two algebras
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math>
we say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\varphi: A\to B</annotation></semantics></math>
is a <em>homomorphism</em> if it is linear and respects the product.
That is,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>λ</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>λ</mi><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>;</mo><mspace width="1.0em"></mspace><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mo>∀</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mi>A</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\varphi(a+ \lambda b)= \varphi(a)+ \lambda  \varphi(b);\quad \varphi(ab)=\varphi(a) \varphi(b) , \quad\forall a ,b \in  A.
&#9;&#9;
\end{aligned}</annotation></semantics></math> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math>
are unital and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(1)=1</annotation></semantics></math>
we say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
is <em>unital</em>. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
has an inverse
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>φ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\varphi^{-1}</annotation></semantics></math>
are continuous we say that it is a <em>homeomorphism</em></em></p>
</div>
<p>Note that any morphism
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
between unital algebras conserves invertability. However that, even if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math>
are unital it may be the case that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varphi(1)</annotation></semantics></math>
is not (consider for example the zero morphism).</p>
<div class="definition">
<p><strong>Definition 6</strong>. <em>We say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
is a character of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">\varphi:A\to \mathbb{C}</annotation></semantics></math>
is a homomorphism.</em></p>
</div>
<div class="definition">
<p><strong>Definition 7</strong>. <em>Given an algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
we say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B \subset A</annotation></semantics></math>
is a sub-algebra if it is subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
closed under multiplication. That is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
itself is an algebra.</em></p>
</div>
<div class="definition">
<p><strong>Definition 8</strong>. <em>Given an algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
we say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">I \subset A</annotation></semantics></math>
is an <em>ideal</em> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
is stable under multiplication with elements is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.
That is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>A</mi><mi>I</mi><mo>:=</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mi>b</mi><mo>:</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo>,</mo><mspace width="1.0em"></mspace><mi>b</mi><mo>∈</mo><mi>I</mi><mo stretchy="false" form="postfix">}</mo><mo>⊂</mo><mi>I</mi><mo>;</mo><mspace width="1.0em"></mspace><mi>I</mi><mi>A</mi><mo>⊂</mo><mi>I</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;AI := \{ a b: a\in A, \quad  b \in I \} \subset I; \quad IA \subset I .
&#9;&#9;
\end{aligned}</annotation></semantics></math> We say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
is <em>maximal</em> if given any other ideal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">I\subset J</annotation></semantics></math>
it holds that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">J=A</annotation></semantics></math>.</em></p>
</div>
<p>We recall that, by Zorn’s Lemma every algebra has a maximal
ideal.</p>
<div class="definition">
<p><strong>Definition 9</strong>. <em>Given a closed ideal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
of an algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
we define the quotient algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>/</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">A/I</annotation></semantics></math>
to be the set of equivalence classes under the relation
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>a</mi><mo>∼</mo><mi>b</mi><mo>⇔</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo>∈</mo><mi>I</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;a \sim b \iff a-b \in I.
&#9;&#9;
\end{aligned}</annotation></semantics></math> With the product
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">¯</mo></mover><mover><mi>b</mi><mo accent="true">¯</mo></mover><mo>:=</mo><mover><mrow><mi>a</mi><mi>b</mi></mrow><mo accent="true">¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{a}\overline{b}:= \overline{ab}</annotation></semantics></math>
and the norm
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mo stretchy="false" form="prefix">∥</mo><mover><mi>a</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">∥</mo><mo>:=</mo><munder><mo>inf</mo><mrow><mi>b</mi><mo>∈</mo><mi>I</mi></mrow></munder><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false" form="postfix">∥</mo><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\lVert \overline{a} \rVert:= \inf_{ b \in  I } \lVert a+b \rVert.
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
</div>
<p>We note that it is necessary for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
to be closed so that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">∥</mo><mover><mi>a</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">∥</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lVert \overline{a} \rVert=0</annotation></semantics></math>
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">a \in I</annotation></semantics></math>,
that is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">¯</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\overline{a}=0</annotation></semantics></math>.</p>
<h1 id="introduction">Introduction</h1>
<h1 id="the-big-theorems">The big theorems</h1>
<p>We now state the main theorems and outline the proof</p>
<div class="theorem">
<p><strong>Theorem 1</strong>. <em>Given a unital Banach algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
it holds that</em></p>
<ol>
<li><p><em>The set of invertible elements in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is open.</em></p></li>
<li><p><em>Taking the inverse is smooth.</em></p></li>
<li><p><em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sigma (a)</annotation></semantics></math>
is a closed subset of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo stretchy="false" form="postfix">∥</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\subset B(0,\lVert a \rVert)</annotation></semantics></math></em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> All of these facts can be proved via the Von-Neumman
series for the inverse
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mo accent="false">∞</mo></munderover><msup><mi>a</mi><mi>n</mi></msup><mo>,</mo><mspace width="1.0em"></mspace><mo>∀</mo><mi>a</mi><mo>∈</mo><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;(1 -a)^{-1}=\sum_{n=0}^{\infty} a^n, \quad\forall a \in B(0,1) .
&#9;&#9;
\end{aligned}</annotation></semantics></math> ◻</p>
</div>
<div class="theorem">
<p><strong>Theorem 2</strong> (Gelfand’s theorem). <em>Given a unital
Banach algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≠</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\sigma (a)\neq \emptyset</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in A</annotation></semantics></math>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Suppose not, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(\lambda 1-a)^{-1}</annotation></semantics></math>
exists for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">\lambda \in  \mathbb{C}</annotation></semantics></math>.
Let us consider the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>ℂ</mi><mo>→</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">f:\mathbb{C}\to \mathbb{C}</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\label{e1}
&#9;&#9;&#9;f(\lambda):= (\lambda 1-a)^{-1}.
&#9;&#9;
\end{aligned}</annotation></semantics></math> Since taking inverse is
smooth,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
is smooth and thus bounded on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo stretchy="false" form="postfix">∥</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">B(0,2\lVert a \rVert)</annotation></semantics></math>.
Furthermore, using Neumann’s series for the inverse we obtain that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mo stretchy="false" form="prefix">∥</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">∥</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">|</mo><msup><mi>λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">|</mo></mrow><mo stretchy="false" form="prefix">∥</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mo accent="false">∞</mo></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>/</mi><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo stretchy="false" form="postfix">∥</mo><mo>≤</mo><msup><mrow><mo stretchy="true" form="prefix">|</mo><mi>λ</mi><mo stretchy="true" form="postfix">|</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mo accent="false">∞</mo></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo stretchy="false" form="postfix">∥</mo><mi>/</mi><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo>≤</mo><mfrac><mn>1</mn><mrow><mo stretchy="true" form="prefix">|</mo><mi>λ</mi><mo stretchy="true" form="postfix">|</mo></mrow></mfrac><mo>≤</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo stretchy="false" form="postfix">∥</mo></mrow></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\lVert f(\lambda ) \rVert = \left| \lambda^{-1} \right| \lVert \sum_{n=0}^{\infty}  (a / \lambda)^n  \rVert\leq \left| \lambda \right|^{-1} \sum_{n=0}^{\infty} (\lVert a \rVert / \lambda)^n \leq \frac{1}{\left|  \lambda  \right|}\leq \frac{1}{2 \lVert a \rVert}  .
&#9;&#9;
\end{aligned}</annotation></semantics></math> As a result
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
is a bounded smooth function and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell (f(\lambda ))</annotation></semantics></math>
is a bounded entire function for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ℓ</mo><mo>∈</mo><msup><mi>A</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\ell \in A^*</annotation></semantics></math>.
By Liouville’s theorem
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell (f(\lambda ))</annotation></semantics></math>
is constant. Since this holds for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ℓ</mo><mo>∈</mo><msup><mi>A</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\ell \in  A^*</annotation></semantics></math>
we deduce that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\lambda )</annotation></semantics></math>
is constant. This leads to a contradiction by taking
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>λ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda =1, \lambda =0</annotation></semantics></math>
as we get
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>I</mi><mo>−</mo><mi>a</mi><mo>=</mo><mi>a</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\label{e2}
&#9;&#9;&#9;I -a= a   .
&#9;&#9;
\end{aligned}</annotation></semantics></math> Citing <a href="#e1"
data-reference-type="eqref" data-reference="e1">[e1]</a> and <a
href="#e2" data-reference-type="eqref" data-reference="e2">[e2]</a> and
referencing <span class="citation"
data-cites="murphy2014c"></span>. ◻</p>
</div>
<p>We now discuss Gelfand’s representation theorem. First some
lemmas</p>
<div class="lemma">
<p><strong>Lemma 1</strong> (<strong>Codimension of a maximal ideal is
1</strong> ). <em>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
be a maximal ideal in a commutative unital Banach Algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≃</mo><mi>I</mi><mo>+</mo><mi>ℂ</mi><mo>⋅</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A \simeq I+ \mathbb{C}\cdot 1</annotation></semantics></math>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> We must show that any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>
can be written
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>+</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">b+\lambda</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">b\in I</annotation></semantics></math>.
Given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">¯</mo></mover><mo>∈</mo><mi>A</mi><mi>/</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">\overline{a} \in A/I</annotation></semantics></math>
there exists by Gelfand’s theorem
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">\lambda  \in  \mathbb{C}</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mrow><mi>λ</mi><mo>−</mo><mi>a</mi></mrow><mo accent="true">¯</mo></mover><annotation encoding="application/x-tex">\overline{\lambda -a}</annotation></semantics></math>
is not invertible. Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>/</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">A /I</annotation></semantics></math>
is a field we deduce that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mrow><mi>λ</mi><mo>−</mo><mi>a</mi></mrow><mo accent="true">¯</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\overline{\lambda -a}=0</annotation></semantics></math>,
that is there exists
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">b \in  I</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>+</mo><mi>λ</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b+ \lambda =a</annotation></semantics></math>
as desired. ◻</p>
</div>
<div class="proposition">
<p><strong>Proposition 1</strong>. <em>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
be a commutative Banach algebra.There is a bijective
correspondence</em></p>
<p><em><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo></mtd><mtd columnalign="left" style="text-align: left"><mo>≃</mo><mo stretchy="false" form="prefix">{</mo><mrow><mtext mathvariant="normal">Maximal ideals </mtext><mspace width="0.333em"></mspace></mrow><mi>I</mi><mo>⊂</mo><mi>A</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mi>φ</mi><mo>↦</mo><mtext mathvariant="normal">ker</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>φ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\Omega(A): &amp; \simeq \{\text{Maximal ideals } I \subset A\}  . \\
&#9;&#9;&#9;           &amp; \varphi    \longmapsto \text{ker}(\varphi).
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
<div class="proof">
<p><em><em>Proof.</em> The mapping is well defined as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mtext mathvariant="normal">ker</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>φ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a -\varphi(a) \in \text{ker}(\varphi)</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in  A</annotation></semantics></math>
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">ker</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>φ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{ker}(\varphi)</annotation></semantics></math>
is maximal. The mapping is surjective by the previous lemma as given a
maximal ideal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
we have that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>I</mi><mo>⊕</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">A=I \oplus \mathbb{C}</annotation></semantics></math>
and we can define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\varphi((a,\lambda )):= \lambda</annotation></semantics></math>.
The mapping is injective as if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">ker</mtext><msub><mi>φ</mi><mn>1</mn></msub><mo>=</mo><mtext mathvariant="normal">ker</mtext><msub><mi>φ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\text{ker}\varphi_1=\text{ker} \varphi_2</annotation></semantics></math>
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>−</mo><msub><mi>φ</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varphi_1(a -\varphi_2(a))=0</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in  A</annotation></semantics></math>. ◻</em></p>
</div>
</div>
<div class="proposition">
<p><strong>Proposition 2</strong>. <em>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
be a commutative Banach algebra. Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">∥</mo><mi>φ</mi><mo stretchy="false" form="postfix">∥</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lVert \varphi \rVert=1</annotation></semantics></math>
for every
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\varphi \in A</annotation></semantics></math>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> We have that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊂</mo><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊂</mo><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo stretchy="false" form="postfix">∥</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varphi(a) \subset \sigma (a)\subset B(0,\lVert a \rVert)</annotation></semantics></math>
as a result
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">∥</mo><mi>φ</mi><mo stretchy="false" form="postfix">∥</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lVert \varphi \rVert\leq 1</annotation></semantics></math>.
On the other hand
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(1)^2=1</annotation></semantics></math>
proves that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(1)=1</annotation></semantics></math>
(we recall that characters by definition are non-zero). This shows that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">∥</mo><mi>φ</mi><mo stretchy="false" form="postfix">∥</mo><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lVert \varphi \rVert \geq 1</annotation></semantics></math>
and concludes the proof. ◻</p>
</div>
<div class="theorem">
<p><strong>Theorem 3</strong>. <em>Given a commutative unital Banach
algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
it holds that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo><mi>φ</mi><mo>∈</mo><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\sigma (a)=\{\varphi(a): \varphi \in \Omega(A)\} .
&#9;&#9;
\end{aligned}</annotation></semantics></math> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is not unital then
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo><mi>φ</mi><mo>∈</mo><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\sigma (a)=\{\varphi(a): \varphi \in \Omega(A)\} \cup \{0\}  .
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
</div>
<div class="proof">
<p><em>Proof.</em> To prove the direct inclusion consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∉</mo><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda \not\in \sigma (a)</annotation></semantics></math>,
then we may take by Zorn’s lemma a proper maximal ideal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>−</mo><mi>a</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\lambda -a \in I</annotation></semantics></math>.
By the previous proposition we can take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mtext mathvariant="normal">ker</mtext><mi>φ</mi></mrow><annotation encoding="application/x-tex">I =\text{ker} \varphi</annotation></semantics></math>
for some character
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>,
from which we deduce that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo>−</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>λ</mi><mo>−</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varphi(\lambda -a)=\lambda -\varphi(a)=0</annotation></semantics></math>.</p>
<p>The reverse inclusion is immediate from the fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>−</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varphi(a-\varphi(a))=0</annotation></semantics></math>
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a- \varphi(a)</annotation></semantics></math>
is not invertible for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in  A</annotation></semantics></math>.</p>
<p>Suppose now
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is not unital, then we unitize it by considering
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>A</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math>
as previously. The characters of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>A</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math>
are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>τ</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Omega(A) \cup \{\tau_0\}</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\tau_0((a,\lambda )):= \lambda</annotation></semantics></math>.
Applying the just prove result to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>A</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math>
shows that, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\tau_0(a,0)=0</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>a</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo><mi>φ</mi><mo>∈</mo><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\sigma (a):=\sigma (\tilde{a})=\{\varphi(a): \varphi \in \Omega(A)\} \cup \{0\}  .
&#9;&#9;
\end{aligned}</annotation></semantics></math> ◻</p>
</div>
<p>We now consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mo>*</mo></msup><annotation encoding="application/x-tex">A^*</annotation></semantics></math>
with the weak* topology and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>
included within it. We recall that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mo>*</mo></msup><annotation encoding="application/x-tex">A^*</annotation></semantics></math>
is Hausdorff and thus so must be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>.</p>
<div class="theorem">
<p><strong>Theorem 4</strong>. <em>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
be an Abelian Banach algebra. Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>
is locally compact. Furthermore, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is also unital then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>
is compact.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> By the previous theorem we know that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊂</mo><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A) \subset B(0,1)</annotation></semantics></math>
whihc is compact with the weak star topology (Banach Aloglu’s theorem).
Now, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varphi_n(a) \to \varphi(a)</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>
then it holds that, by a simple argument
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
is also a morphism. Thus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
will be a character if and only if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varphi \neq 0</annotation></semantics></math>.
For this reason it is necessary to adjoin
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is not unital. This shows that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Omega(A) \cup  \{0\}</annotation></semantics></math>
is closed in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">B(0,1)</annotation></semantics></math>
and is thus compact. In consequence
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>
is locally compact.</p>
<p>Suppose now that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is unital, then we have seen than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">∥</mo><mi>φ</mi><mo stretchy="false" form="postfix">∥</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lVert \varphi \rVert=1</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>∈</mo><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varphi \in  \Omega(A)</annotation></semantics></math>.
The previous argument shows that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>
is closed (we can never reach
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>)
and as a result
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>
is compact. ◻</p>
</div>
<p>We can now identify
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
with a sub-algebra of continuous functions on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(A)</annotation></semantics></math>
via the mapping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">a \to \widehat{a}</annotation></semantics></math>
where we define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>φ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\widehat{a}(\varphi):= \varphi(a)</annotation></semantics></math>.
Let us denote the image of this mapping by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>A</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\widehat{A}</annotation></semantics></math>,
then we obtain the following theorem</p>
<div class="theorem">
<p><strong>Theorem 5</strong> (<strong>Gelfand’s represntation
theorem</strong>). <em>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
be a commutative Banach algebra, then the mapping
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>A</mi><mo>→</mo><mover><mi>A</mi><mo accent="true">̂</mo></mover><mo>⊂</mo><msub><mi>C</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>;</mo><mspace width="1.0em"></mspace><mi>a</mi><mo>→</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;A \to\widehat{A} \subset C_0(\Omega(A)); \quad a\to \widehat{a}.
&#9;&#9;
\end{aligned}</annotation></semantics></math> is a norm decreasing
injective homomorphism with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">∥</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">∥</mo><mo>=</mo><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lVert \widehat{a} \rVert= r(a)</annotation></semantics></math>.
Furhtermore, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
is unital then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sigma (a)=\widehat{a}(\Omega(A))</annotation></semantics></math>
and otherwise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\sigma (a)=\widehat{a}(\Omega(A)) \cup  \{0\}</annotation></semantics></math>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> To show that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>a</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\widehat{a}</annotation></semantics></math>
vanishes at infinity note that the set
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mo stretchy="false" form="prefix">{</mo><mi>φ</mi><mo>:</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>φ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≥</mo><mi>ϵ</mi><mo stretchy="false" form="postfix">}</mo><mo>=</mo><msup><mover><mi>a</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>ϵ</mi><mo>,</mo><mo stretchy="false" form="prefix">∥</mo><mi>a</mi><mo stretchy="false" form="postfix">∥</mo><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\{\varphi : \widehat{a}(\varphi) \geq \epsilon \} =\widehat{a}^{-1}([\epsilon ,\lVert a \rVert]).
&#9;&#9;
\end{aligned}</annotation></semantics></math> Which is a closed subset
in the compact
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">B(0,a)</annotation></semantics></math>
and thus compact. ◻</p>
</div>
<p>We note however that the mapping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mover><mi>a</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">a \to \widehat{a}</annotation></semantics></math>
is in general neither injective (this means the identification isn’t
prefect) not surjective.</p>
<div class="example">
<p><strong>Example 1</strong> (Continuous Fourier Transform).
<em>Consider the Banach Algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>L</mi><mn>1</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A=L^1(\mathbb{R}^d)</annotation></semantics></math>
with multiplication given by the convolution
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>f</mi><mo>*</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msub><mo>∫</mo><msup><mi>ℝ</mi><mi>d</mi></msup></msub><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi>y</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;f*g(x):= \int_{\mathbb{R}^d}f(y)g(x-y) \,\mathrm{d}y.
&#9;&#9;
\end{aligned}</annotation></semantics></math> Then the Gelfand transform
can be identified with the Fourier transform and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mover><mi>f</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ω</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mover><mi>f</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>ω</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msub><mo>∫</mo><msup><mi>ℝ</mi><mi>d</mi></msup></msub><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>ω</mi><mo>⋅</mo><mi>x</mi></mrow></msup><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi>x</mi><mo>:</mo><mi>ω</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">}</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\widehat{f}(\Omega)= \left\{ \widehat{f}(\omega):= \int_{\mathbb{R}^d} f(x)e^{-2\pi i \omega \cdot  x} \,\mathrm{d}x:\omega\in \mathbb{R}^d\right\} .
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
</div>
<div class="proof">
<p><em>Proof.</em> We know that the dual of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>1</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L^1(\mathbb{R}^d)</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mi>∞</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L^\infty(\mathbb{R}^d)</annotation></semantics></math>.
In particular every character is of the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>φ</mi><mi>g</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>∫</mo><msup><mi>ℝ</mi><mi>d</mi></msup></msub><mi>f</mi><mover><mi>g</mi><mo accent="true">¯</mo></mover><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\varphi_g (f)= \int_{\mathbb{R}^d}f \overline{g}.
&#9;&#9;
\end{aligned}</annotation></semantics></math> The condition that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>g</mi></msub><annotation encoding="application/x-tex">\varphi_g</annotation></semantics></math>
preserves multiplication becomes by a change of variable
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mo>∀</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;g(x+y)=g(x)g(y), \quad\forall x,y \in \mathbb{R}^d.
&#9;&#9;
\end{aligned}</annotation></semantics></math> The only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><msup><mi>L</mi><mi>∞</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g \in L^\infty (\mathbb{R}^d)</annotation></semantics></math>
verifying the above are of the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>ω</mi><mo>⋅</mo><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g(x)= e^{2\pi i \omega \cdot  x}</annotation></semantics></math>
for some
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">\omega \in \mathbb{R}^d</annotation></semantics></math>.
That is, the character group is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>L</mi><mn>1</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>≃</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>ω</mi><mo>⋅</mo></mrow></msup><mo>:</mo><mi>ω</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\Omega(L^1(\mathbb{R}^d))\simeq\{e^{2\pi i \omega \cdot }: \omega \in \mathbb{R}^d\} .
&#9;&#9;
\end{aligned}</annotation></semantics></math> This concludes the proof
(we use the abuse of notation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>ω</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mover><mi>f</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>φ</mi><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>ω</mi><mo>⋅</mo></mrow></msup></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\widehat{f}(\omega):=\widehat{f}(\varphi_{e^{2\pi i \omega \cdot }})</annotation></semantics></math>). ◻</p>
</div>
<div class="example">
<p><strong>Example 2</strong> (Discrete Fourier Transform). <em>Consider
the Banach Algebra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mo>ℓ</mo><mi>∞</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ℤ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A=\ell ^\infty(\mathbb{Z}^d)</annotation></semantics></math>
with multiplication given by the convolution
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>g</mi><mo>*</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo>∈</mo><msup><mi>ℤ</mi><mi>d</mi></msup></mrow></munder><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>−</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;g*h(k):= \sum_{k \in \mathbb{Z}^d}g(j)h(k-j) .
&#9;&#9;
\end{aligned}</annotation></semantics></math> Then the Gelfand transform
can be identified with the (inverse) Fourier transform and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mover><mi>g</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ω</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mover><mi>g</mi><mo accent="true">̌</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo>∈</mo><msup><mi>ℤ</mi><mi>d</mi></msup></mrow></munder><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>k</mi><mo>⋅</mo><mi>x</mi></mrow></msup><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi>x</mi><mo>:</mo><mi>k</mi><mo>∈</mo><msup><mi>ℤ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">}</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\widehat{g}(\Omega)= \left\{ \check{g}(k):= \sum_{k \in \mathbb{Z}^d} g(x)e^{2\pi i k \cdot  x} \,\mathrm{d}x: k\in \mathbb{Z}^d\right\} .
&#9;&#9;
\end{aligned}</annotation></semantics></math></em></p>
</div>
<p>Furthermore
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mover><mi>g</mi><mo accent="true">̌</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mi>x</mi></mrow></msup><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi>x</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;g(k)=\int_{0}^1 \check{g}(k)e^{2 \pi i (j-k) \cdot x}\,\mathrm{d}x.
&#9;
\end{aligned}</annotation></semantics></math></p>
<div class="proof">
<p><em>Proof.</em> Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><msub><mi>e</mi><mi>d</mi></msub><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">e_1,\ldots e_d \in A</annotation></semantics></math>
be defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>e</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msub><mi>δ</mi><mrow><mi>n</mi><msub><mi>k</mi><mn>1</mn></msub></mrow></msub><mo>,</mo><mspace width="1.0em"></mspace><mo>∀</mo><mi>n</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mi>d</mi><mo>,</mo><mi>k</mi><mo>∈</mo><msup><mi>ℤ</mi><mi>d</mi></msup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;e_n(k):= \delta _{nk_1}, \quad\forall n=1,\ldots d, k\in \mathbb{Z}^d .
&#9;&#9;
\end{aligned}</annotation></semantics></math> Then we have that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is generated by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><msub><mi>e</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">e_{1},\ldots e_n</annotation></semantics></math>
with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>∑</mo><mi>k</mi></munder><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>e</mi><mn>1</mn><msub><mi>k</mi><mn>1</mn></msub></msubsup><mi>…</mi><msubsup><mi>e</mi><mi>d</mi><msub><mi>k</mi><mi>d</mi></msub></msubsup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;g(k) =\sum_{k} g(k) e_1^{k_1}\ldots e_d ^{k_d} .
&#9;&#9;
\end{aligned}</annotation></semantics></math> Any character
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>
is thus determined by where it sends the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>n</mi></msub><annotation encoding="application/x-tex">e_n</annotation></semantics></math>
and they take the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>φ</mi><mi>z</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo>∈</mo><msup><mi>ℤ</mi><mi>d</mi></msup></mrow></munder><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>z</mi><mi>k</mi></msup><mo>:</mo><mi>z</mi><mo>∈</mo><msup><mi>𝕋</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">}</mo></mrow><mo>≃</mo><msup><mi>𝕋</mi><mi>d</mi></msup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\Omega(A)= \left\{ \varphi_z (g):= \sum_{k \in \mathbb{Z}^d} g(k) z^k: z \in \mathbb{T}^d  \right\} \simeq \mathbb{T}^d .
&#9;&#9;
\end{aligned}</annotation></semantics></math> Noting that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝕋</mi><mi>d</mi></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi></mrow></msup><mo>:</mo><mi>x</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{T}^d= \left\{ e^{ 2\pi i x}: x \in \mathbb{R}^d \right\}</annotation></semantics></math>
and defining
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mover><mi>g</mi><mo accent="true">̌</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msub><mi>φ</mi><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi><mo>⋅</mo></mrow></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo>∈</mo><msup><mi>ℤ</mi><mi>d</mi></msup></mrow></munder><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>k</mi><mo>⋅</mo><mi>x</mi></mrow></msup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\check{g}(x):= \varphi_{e^{ 2\pi i x \cdot  }}(g)=\sum_{k \in \mathbb{Z}^d} g(k) e^{2 \pi  i k \cdot x}.
&#9;&#9;
\end{aligned}</annotation></semantics></math> Gives the first part of
the proof and using the orthonormality trick
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mover><mi>g</mi><mo accent="true">̌</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>k</mi><mo>⋅</mo><mi>x</mi></mrow></msup><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi>x</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><msup><mi>ℤ</mi><mi>d</mi></msup></mrow></munder><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mi>x</mi></mrow></msup><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi>x</mi><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&#9;&#9;&#9;\int_{0}^1 \check{g}(x) e^{-2 \pi i k \cdot x}\,\mathrm{d}x=\sum_{j \in \mathbb{Z}^d} g(j)  \int_{0}^1 e^{2 \pi i (j-k) \cdot x}\,\mathrm{d}x= g(k).
&#9;&#9;
\end{aligned}</annotation></semantics></math> Gives the second. Where in
the above we applied the dominated convergence theorem. ◻</p>
</div>
</div>
>>>>>>> parent of c4cd150 (test2 in jax)
